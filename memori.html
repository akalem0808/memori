<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio-Visual Memory Assistant</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #ffffff; /* Changed to white */
            color: #000000; /* Changed to black for contrast */
            line-height: 1.6;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            background-color: #f0f0f0; /* Slightly off-white for distinction */
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1); /* Lighter shadow */
            padding: 30px;
            box-sizing: border-box;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid #cccccc; /* Lighter border */
        }

        .header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            color: #000000; /* Changed to black */
            margin-bottom: 10px;
            letter-spacing: -0.05em;
        }

        .header p {
            font-size: 1.1rem;
            color: #333333; /* Darker gray for readability */
            font-weight: 300;
        }

        .main-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }

        .card {
            background: #ffffff; /* Changed to white */
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1); /* Lighter shadow */
            display: flex;
            flex-direction: column;
            gap: 15px;
            border: 1px solid #e0e0e0; /* Added light border */
        }

        .card h2 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #000000; /* Changed to black */
            margin-bottom: 15px;
            border-bottom: 2px solid #e0e0e0; /* Lighter border */
            padding-bottom: 10px;
        }

        /* Camera Section */
        .camera-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 4:3 Aspect Ratio (480/640 = 0.75) */
            background-color: #000000; /* Keep black for video feed */
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #cccccc; /* Lighter border */
        }

        .camera-container video, .camera-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect for selfie camera */
        }

        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.6); /* Keep dark overlay */
            color: #ffffff; /* Keep white text */
            font-size: 1.2rem;
            font-weight: 500;
            z-index: 10;
        }

        .camera-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .camera-button {
            flex: 1;
            padding: 12px 20px;
            background: #e0e0e0; /* Lighter background */
            color: #000000; /* Black text */
            border: none;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
        }

        .camera-button:hover:not(:disabled) {
            background: #d0d0d0; /* Slightly darker on hover */
            transform: translateY(-2px);
        }

        .camera-button:disabled {
            background: #f0f0f0; /* Lighter disabled state */
            color: #888888;
            cursor: not-allowed;
        }

        .movement-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0; /* Lighter border */
        }

        .metric-item {
            background: #f8f8f8; /* Lighter background */
            border-radius: 8px;
            padding: 10px 15px;
            text-align: center;
            border: 1px solid #e0e0e0; /* Lighter border */
        }

        .metric-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #000000; /* Black text */
            margin-bottom: 2px;
        }

        .metric-label {
            font-size: 0.8rem;
            color: #333333; /* Darker gray */
            font-weight: 400;
        }

        .body-language-summary {
            background: #f8f8f8; /* Lighter background */
            border: 1px solid #e0e0e0; /* Lighter border */
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .body-language-summary h4 {
            color: #000000; /* Black text */
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .body-language-summary p {
            color: #333333; /* Darker gray */
            font-size: 0.9rem;
            line-height: 1.4;
        }

        /* Recording Section */
        .record-button {
            background: linear-gradient(145deg, #ff4d4d, #cc0000); /* Keep red for recording */
            color: #ffffff;
            border: none;
            padding: 18px 30px;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 15px rgba(255, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .record-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 20px rgba(255, 0, 0, 0.4);
        }

        .record-button.recording {
            background: linear-gradient(145deg, #4d4dff, #0000cc); /* Keep blue for recording state */
            box-shadow: 0 8px 15px rgba(0, 0, 255, 0.3);
        }

        .record-button.recording:hover {
            background: linear-gradient(145deg, #6666ff, #0000ee);
            box-shadow: 0 12px 20px rgba(0, 0, 255, 0.4);
        }

        .record-button::before {
            content: '';
            display: inline-block;
            width: 18px;
            height: 18px;
            background-color: #ffffff;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .record-button.recording::before {
            background-color: #ff0000;
            border-radius: 3px;
            animation: none;
        }

        @keyframes pulse {
            0% { transform: scale(0.8); opacity: 0.7; }
            50% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.7; }
        }

        #recordingStatus, #uploadStatus {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #333333; /* Darker for readability */
        }

        .file-upload {
            background: #f8f8f8; /* Lighter background */
            border: 2px dashed #cccccc; /* Lighter border */
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.3s ease, background-color 0.3s ease;
        }

        .file-upload:hover {
            border-color: #999999; /* Darker border on hover */
            background-color: #e8e8e8; /* Slightly darker on hover */
        }

        .file-upload input[type="file"] {
            display: none;
        }

        .file-upload p {
            margin: 0;
            color: #000000; /* Black text */
            font-weight: 500;
        }

        .file-upload small {
            color: #666666; /* Darker gray */
            font-size: 0.8rem;
        }

        /* Query Section */
        .query-input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #cccccc; /* Lighter border */
            border-radius: 25px;
            font-size: 1rem;
            font-family: 'Inter', sans-serif;
            font-weight: 400;
            outline: none;
            transition: border-color 0.3s ease;
            background: #ffffff; /* White background */
            color: #000000; /* Black text */
        }

        .query-input::placeholder {
            color: #999999; /* Lighter placeholder */
            font-weight: 400;
        }

        .query-input:focus {
            border-color: #666666; /* Darker border on focus */
        }

        .query-button {
            background: #000000; /* Changed to black */
            color: #ffffff; /* Changed to white */
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s ease;
        }

        .query-button:hover {
            transform: translateY(-2px);
            background: #333333; /* Darker on hover */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2); /* Adjusted shadow */
        }

        .query-filters {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .filter-tag {
            background: #e0e0e0; /* Lighter background */
            color: #333333; /* Darker text */
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid #cccccc; /* Lighter border */
        }

        .filter-tag.active {
            background: #000000; /* Changed to black */
            color: #ffffff; /* Changed to white */
            border-color: #000000; /* Changed to black */
        }

        /* Results Section */
        .full-width {
            grid-column: 1 / -1;
        }

        .memory-item {
            background: #f8f8f8; /* Lighter background */
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #000000; /* Changed to black */
            transition: all 0.3s ease;
            border: 1px solid #e0e0e0; /* Added light border */
        }

        .memory-item:hover {
            background: #e8e8e8; /* Slightly darker on hover */
            transform: translateX(5px);
        }

        .memory-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 500;
            color: #666666; /* Darker gray */
        }

        .emotion-tag {
            background: #cccccc; /* Lighter background */
            color: #333333; /* Darker text */
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
            border: 1px solid #999999; /* Darker border */
        }

        .memory-text {
            font-size: 1rem;
            line-height: 1.6;
            color: #000000; /* Black text */
            font-weight: 400;
        }

        .multimodal-summary {
            background: #e0e0e0; /* Lighter background */
            border: 1px solid #cccccc; /* Lighter border */
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .multimodal-summary h5 {
            color: #000000; /* Black text */
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .multimodal-summary p {
            color: #333333; /* Darker gray */
            font-size: 0.8rem;
            line-height: 1.4;
        }

        /* Stats Dashboard */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: #000000;
            margin-bottom: 5px;
            letter-spacing: -0.025em;
        }

        .stat-label {
            color: #333333;
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* Loading states */
        .loading {
            text-align: center;
            padding: 40px;
            color: #666666; /* Darker for readability */
            font-weight: 500;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #cccccc; /* Lighter border */
            border-top: 4px solid #000000; /* Black spinner top */
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }

            .movement-metrics {
                grid-template-columns: 1fr;
            }
        }

        /* Modal specific styles for playback */
        .playback-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 4:3 Aspect Ratio */
            background-color: #000000;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #cccccc;
            margin-bottom: 20px;
        }

        .playback-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            background-color: #000000; /* Black background for playback */
        }

        .playback-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .playback-button {
            background: #000000;
            color: #ffffff;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .playback-button:hover {
            background: #333333;
        }

        .playback-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Audio-Visual Memory Assistant</h1>
            <p>Your AI-powered memory companion with body language analysis</p>
        </div>

        <!-- Stats Dashboard -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number" id="totalMemories">0</div>
                <div class="stat-label">Total Memories</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="recentMemories">0</div>
                <div class="stat-label">This Week</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="avgEngagement">0%</div>
                <div class="stat-label">Avg Engagement</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="topGesture">-</div>
                <div class="stat-label">Most Common Gesture</div>
            </div>
        </div>

        <div class="main-grid">
            <!-- Camera Section -->
            <div class="card">
                <h2>Visual Analysis</h2>
                <div class="camera-container">
                    <video id="videoPreview" autoplay muted></video>
                    <canvas id="outputCanvas"></canvas>
                    <div class="camera-overlay" id="cameraStatus">Camera Off</div>
                </div>
                
                <div class="camera-controls">
                    <button id="startCameraButton" class="camera-button">Start Camera</button>
                    <button id="stopCameraButton" class="camera-button" disabled>Stop Camera</button>
                </div>

                <div class="movement-metrics" id="movementMetrics" style="display: none;">
                    <div class="metric-item">
                        <div class="metric-value" id="movementIntensity">0%</div>
                        <div class="metric-label">Movement</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" id="engagementLevel">0%</div>
                        <div class="metric-label">Engagement</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" id="currentGesture">None</div>
                        <div class="metric-label">Current Gesture</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" id="postureType">Neutral</div>
                        <div class="metric-label">Posture</div>
                    </div>
                </div>

                <div class="body-language-summary" id="bodyLanguageSummary" style="display: none;">
                    <h4>Body Language Analysis</h4>
                    <p id="bodyLanguageText">Enable camera to see analysis</p>
                </div>
            </div>

            <!-- Recording Section -->
            <div class="card">
                <h2>Record Memory</h2>
                <button id="recordButton" class="record-button">
                    <span id="recordText">Start Recording</span>
                </button>
                <div id="recordingStatus"></div>
                
                <div class="file-upload" onclick="document.getElementById('audioFile').click()">
                    <input type="file" id="audioFile" accept="audio/*">
                    <p>Or upload an audio file</p>
                    <small>Supports MP3, WAV, M4A, and more</small>
                </div>
                
                <div id="uploadStatus"></div>
            </div>

            <!-- Query Section -->
            <div class="card">
                <h2>Query Memories</h2>
                <input 
                    type="text" 
                    id="queryInput" 
                    class="query-input" 
                    placeholder="What would you like to remember? e.g., 'When was I most engaged during meetings?'"
                >
                <button id="queryButton" class="query-button">Search Memories</button>
                
                <div class="query-filters">
                    <div class="filter-tag" data-filter="time:1">Last Day</div>
                    <div class="filter-tag" data-filter="time:7">Last Week</div>
                    <div class="filter-tag" data-filter="engagement:high">High Engagement</div>
                    <div class="filter-tag" data-filter="movement:active">Active Movement</div>
                    <div class="filter-tag" data-filter="gesture:confident">Confident Posture</div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="card full-width">
                <h2>Memory Results</h2>
                <div id="queryResults">
                    <p style="text-align: center; color: #666666; padding: 40px; font-weight: 500;">
                        Ask a question to search your audio-visual memories
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Memory Detail Modal -->
    <div class="modal" id="memoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Memory Details</h2>
                <button class="close-button" id="closeModal">&times;</button>
            </div>
            <div id="modalBody">
                <!-- Memory details will be populated here -->
            </div>
        </div>
    </div>

    <script type="module">
        // Import MediaPipe modules
        const Holistic = window.Holistic;
        const Camera = window.Camera;
        const DrawingUtils = window.DrawingUtils;

        class AudioVisualMemoryInterface {
            constructor() {
                this.isRecording = false;
                this.isCameraActive = false;
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.activeFilters = {};
                this.videoStream = null;
                
                this.holistic = null; // MediaPipe Holistic model
                this.camera = null;   // MediaPipe Camera utility
                this.canvasCtx = null; // 2D rendering context for camera output canvas

                this.lastPoseLandmarks = null; // To calculate movement intensity
                this.currentAnalysis = { // Store current real-time analysis
                    movement_intensity: 0,
                    engagement_level: 0,
                    gesture_type: 'none',
                    posture_type: 'neutral',
                    body_language_summary: 'No analysis yet'
                };
                this.recordedVisualFrames = []; // Stores landmark data for playback

                this.playbackCanvas = null;
                this.playbackCtx = null;
                this.playbackAnimationFrameId = null;
                this.playbackFrameIndex = 0;

                this.initializeEventListeners();
                this.loadStats();
            }

            initializeEventListeners() {
                // Recording button
                document.getElementById('recordButton').addEventListener('click', () => {
                    this.toggleRecording();
                });

                // Camera controls
                document.getElementById('startCameraButton').addEventListener('click', () => {
                    this.startCamera();
                });

                document.getElementById('stopCameraButton').addEventListener('click', () => {
                    this.stopCamera();
                });

                // File upload
                document.getElementById('audioFile').addEventListener('change', (e) => {
                    this.handleFileUpload(e.target.files[0]);
                });

                // Query button
                document.getElementById('queryButton').addEventListener('click', () => {
                    this.performQuery();
                });

                // Query input enter key
                document.getElementById('queryInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.performQuery();
                    }
                });

                // Filter tags
                document.querySelectorAll('.filter-tag').forEach(tag => {
                    tag.addEventListener('click', (e) => {
                        this.toggleFilter(e.target);
                    });
                });

                // Modal close button
                document.getElementById('closeModal').addEventListener('click', () => {
                    this.closeModal();
                });

                // Close modal when clicking outside content
                document.getElementById('memoryModal').addEventListener('click', (e) => {
                    if (e.target.id === 'memoryModal') {
                        this.closeModal();
                    }
                });
            }

            async startCamera() {
                const videoElement = document.getElementById('videoPreview');
                const canvasElement = document.getElementById('outputCanvas');
                this.canvasCtx = canvasElement.getContext('2d');

                // Show loading indicator
                document.getElementById('cameraStatus').innerHTML = '<div class="spinner"></div> Loading AI Model...';
                document.getElementById('startCameraButton').disabled = true;
                document.getElementById('stopCameraButton').disabled = true;

                try {
                    // Initialize MediaPipe Holistic
                    this.holistic = new Holistic({
                        locateFile: (file) => {
                            return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;
                        }
                    });

                    this.holistic.setOptions({
                        modelComplexity: 1, // 0, 1, or 2. Higher is more accurate but slower.
                        smoothLandmarks: true,
                        enableSegmentation: false,
                        smoothSegmentation: false,
                        refineFaceLandmarks: true,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    this.holistic.onResults(this.onHolisticResults.bind(this));

                    this.camera = new Camera(videoElement, {
                        onFrame: async () => {
                            if (this.holistic) {
                                await this.holistic.send({ image: videoElement });
                            }
                        },
                        width: 640,
                        height: 480
                    });
                    await this.camera.start();

                    this.isCameraActive = true;
                    document.getElementById('startCameraButton').disabled = true;
                    document.getElementById('stopCameraButton').disabled = false;
                    document.getElementById('cameraStatus').textContent = 'Camera Active - Analyzing Body Language';
                    
                    // Show movement metrics
                    document.getElementById('movementMetrics').style.display = 'grid';
                    document.getElementById('bodyLanguageSummary').style.display = 'block';

                } catch (error) {
                    console.error('Error starting camera or loading AI model:', error);
                    this.showMessageBox('Could not access camera or load AI model. Please check permissions and try again.', 'error');
                    this.stopCamera(); // Ensure UI is reset
                }
            }

            stopCamera() {
                if (this.camera) {
                    this.camera.stop();
                    this.camera = null;
                }
                if (this.holistic) {
                    this.holistic.close();
                    this.holistic = null;
                }
                if (this.canvasCtx) {
                    this.canvasCtx.clearRect(0, 0, document.getElementById('outputCanvas').width, document.getElementById('outputCanvas').height);
                }
                
                this.isCameraActive = false;
                document.getElementById('startCameraButton').disabled = false;
                document.getElementById('stopCameraButton').disabled = true;
                document.getElementById('cameraStatus').textContent = 'Camera Off';
                
                // Hide movement metrics
                document.getElementById('movementMetrics').style.display = 'none';
                document.getElementById('bodyLanguageSummary').style.display = 'none';
                
                const video = document.getElementById('videoPreview');
                video.srcObject = null;
                this.lastPoseLandmarks = null; // Reset for next session
                this.currentAnalysis = { // Reset current analysis
                    movement_intensity: 0,
                    engagement_level: 0,
                    gesture_type: 'none',
                    posture_type: 'neutral',
                    body_language_summary: 'No analysis yet'
                };
                this.updateMovementDisplay(this.currentAnalysis); // Clear display
            }

            onHolisticResults(results) {
                const videoElement = document.getElementById('videoPreview');
                const canvasElement = document.getElementById('outputCanvas');
                
                // Set canvas dimensions to match video
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;

                this.canvasCtx.save();
                this.canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                // Draw the video frame to the canvas (optional, but good for visual debugging)
                this.canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height); 

                // Draw landmarks for real-time visualization
                DrawingUtils.drawConnectors(this.canvasCtx, results.poseLandmarks, Holistic.POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
                DrawingUtils.drawLandmarks(this.canvasCtx, results.poseLandmarks, { color: '#FF0000', lineWidth: 2 });
                DrawingUtils.drawConnectors(this.canvasCtx, results.faceLandmarks, Holistic.FACE_CONNECTIONS, { color: '#FFFFFF', lineWidth: 1 });
                DrawingUtils.drawLandmarks(this.canvasCtx, results.faceLandmarks, { color: '#E0E0E0', lineWidth: 0.5 });
                DrawingUtils.drawConnectors(this.canvasCtx, results.leftHandLandmarks, Holistic.HAND_CONNECTIONS, { color: '#CC0000', lineWidth: 5 });
                DrawingUtils.drawLandmarks(this.canvasCtx, results.leftHandLandmarks, { color: '#FF0000', lineWidth: 2 });
                DrawingUtils.drawConnectors(this.canvasCtx, results.rightHandLandmarks, Holistic.HAND_CONNECTIONS, { color: '#00CC00', lineWidth: 5 });
                DrawingUtils.drawLandmarks(this.canvasCtx, results.rightHandLandmarks, { color: '#00FF00', lineWidth: 2 });

                this.canvasCtx.restore();

                // Derive metrics from results
                this.currentAnalysis = this.deriveMetricsFromHolistic(results);
                this.updateMovementDisplay(this.currentAnalysis);

                // Store simplified landmark data for playback if recording
                if (this.isRecording && results.poseLandmarks) {
                    // Store a simplified snapshot of landmarks to save space
                    const simplifiedLandmarks = {
                        pose: results.poseLandmarks ? results.poseLandmarks.map(l => ({x:l.x, y:l.y, z:l.z})) : null,
                        face: results.faceLandmarks ? results.faceLandmarks.map(l => ({x:l.x, y:l.y, z:l.z})) : null,
                        leftHand: results.leftHandLandmarks ? results.leftHandLandmarks.map(l => ({x:l.x, y:l.y, z:l.z})) : null,
                        rightHand: results.rightHandLandmarks ? results.rightHandLandmarks.map(l => ({x:l.x, y:l.y, z:l.z})) : null,
                    };
                    this.recordedVisualFrames.push(simplifiedLandmarks);
                }
            }

            deriveMetricsFromHolistic(results) {
                let movement_intensity = 0;
                let engagement_level = 0;
                let gesture_type = 'none';
                let posture_type = 'neutral';
                let body_language_summary = 'No visual data available';

                const poseLandmarks = results.poseLandmarks;
                const faceLandmarks = results.faceLandmarks;
                const leftHandLandmarks = results.leftHandLandmarks;
                const rightHandLandmarks = results.rightHandLandmarks;

                if (poseLandmarks) {
                    // Calculate Movement Intensity
                    if (this.lastPoseLandmarks) {
                        let totalDisplacement = 0;
                        for (let i = 0; i < poseLandmarks.length; i++) {
                            const current = poseLandmarks[i];
                            const last = this.lastPoseLandmarks[i];
                            if (current && last) {
                                const dx = current.x - last.x;
                                const dy = current.y - last.y;
                                totalDisplacement += Math.sqrt(dx * dx + dy * dy);
                            }
                        }
                        // Normalize displacement (adjust divisor based on typical movement range)
                        movement_intensity = Math.min(1, totalDisplacement / (poseLandmarks.length * 0.05)); // Arbitrary normalization
                    }
                    this.lastPoseLandmarks = poseLandmarks;

                    // Simplified Posture Type (e.g., upright vs. slouched)
                    const leftShoulder = poseLandmarks[Holistic.POSE_LANDMARKS.LEFT_SHOULDER];
                    const rightShoulder = poseLandmarks[Holistic.POSE_LANDMARKS.RIGHT_SHOULDER];
                    const leftHip = poseLandmarks[Holistic.POSE_LANDMARKS.LEFT_HIP];
                    const rightHip = poseLandmarks[Holistic.POSE_LANDMARKS.RIGHT_HIP];

                    if (leftShoulder && rightShoulder && leftHip && rightHip) {
                        const shoulderMidY = (leftShoulder.y + rightShoulder.y) / 2;
                        const hipMidY = (leftHip.y + rightHip.y) / 2;
                        const torsoHeight = Math.abs(shoulderMidY - hipMidY);

                        if (shoulderMidY > hipMidY - (torsoHeight * 0.2)) {
                             posture_type = 'slouched';
                        } else {
                            posture_type = 'upright';
                        }
                    }

                    // Simplified Engagement Level (e.g., based on head orientation or general movement)
                    if (faceLandmarks && poseLandmarks[Holistic.POSE_LANDMARKS.NOSE]) {
                        const noseX = poseLandmarks[Holistic.POSE_LANDMARKS.NOSE].x;
                        const avgShoulderX = (poseLandmarks[Holistic.POSE_LANDMARKS.LEFT_SHOULDER].x + poseLandmarks[Holistic.POSE_LANDMARKS.RIGHT_SHOULDER].x) / 2;
                        
                        if (Math.abs(noseX - avgShoulderX) < 0.1) {
                            engagement_level = Math.min(1, 0.5 + (movement_intensity * 0.5));
                        } else {
                            engagement_level = Math.min(1, 0.3 + (movement_intensity * 0.3));
                        }
                    } else {
                        engagement_level = movement_intensity * 0.5;
                    }
                    
                    engagement_level = Math.min(1, engagement_level);
                }

                // Simplified Gesture Type (e.g., based on hand positions relative to body)
                if (leftHandLandmarks || rightHandLandmarks) {
                    if (leftHandLandmarks && poseLandmarks && leftHandLandmarks[8] && poseLandmarks[Holistic.POSE_LANDMARKS.LEFT_SHOULDER]) {
                        if (leftHandLandmarks[8].y < poseLandmarks[Holistic.POSE_LANDMARKS.LEFT_SHOULDER].y - 0.1) {
                            gesture_type = 'pointing_up';
                        }
                    }
                    if (rightHandLandmarks && poseLandands && rightHandLandmarks[8] && poseLandmarks[Holistic.POSE_LANDMARKS.RIGHT_SHOULDER]) {
                        if (rightHandLandmarks[8].y < poseLandmarks[Holistic.POSE_LANDMARKS.RIGHT_SHOULDER].y - 0.1) {
                            gesture_type = 'pointing_up';
                        }
                    }
                    // Example for "crossed arms": check if left wrist is near right shoulder and vice-versa
                    const leftWrist = leftHandLandmarks ? leftHandLandmarks[Holistic.HAND_LANDMARKS.WRIST] : null;
                    const rightWrist = rightHandLandmarks ? rightHandLandmarks[Holistic.HAND_LANDMARKS.WRIST] : null;
                    const leftShoulder = poseLandmarks ? poseLandmarks[Holistic.POSE_LANDMARKS.LEFT_SHOULDER] : null;
                    const rightShoulder = poseLandmarks ? poseLandmarks[Holistic.POSE_LANDMARKS.RIGHT_SHOULDER] : null;

                    if (leftWrist && rightWrist && leftShoulder && rightShoulder) {
                        const distLeftWristToRightShoulder = Math.sqrt(Math.pow(leftWrist.x - rightShoulder.x, 2) + Math.pow(leftWrist.y - rightShoulder.y, 2));
                        const distRightWristToLeftShoulder = Math.sqrt(Math.pow(rightWrist.x - leftShoulder.x, 2) + Math.pow(rightWrist.y - leftShoulder.y, 2));
                        
                        // Arbitrary threshold for "crossed arms"
                        if (distLeftWristToRightShoulder < 0.2 && distRightWristToLeftShoulder < 0.2) {
                            gesture_type = 'crossed_arms';
                        }
                    }
                }

                // Generate body language summary
                const engagementSummary = engagement_level > 0.7 ? 'highly engaged' : engagement_level > 0.4 ? 'moderately engaged' : 'less engaged';
                const movementSummary = movement_intensity > 0.6 ? 'active movement' : movement_intensity > 0.2 ? 'some movement' : 'minimal movement';
                const gestureSummary = gesture_type !== 'none' ? `showing a ${gesture_type.replace('_', ' ')} gesture` : 'no distinct gestures';

                body_language_summary = `User appears ${engagementSummary} with ${movementSummary}, and ${gestureSummary}. Posture is ${posture_type}.`;
                if (!poseLandmarks) {
                    body_language_summary = 'No body detected for analysis.';
                }

                return {
                    movement_intensity: movement_intensity,
                    engagement_level: engagement_level,
                    gesture_type: gesture_type,
                    posture_type: posture_type,
                    body_language_summary: body_language_summary
                };
            }

            updateMovementDisplay(analysis) {
                document.getElementById('movementIntensity').textContent = 
                    Math.round(analysis.movement_intensity * 100) + '%';
                document.getElementById('engagementLevel').textContent = 
                    Math.round(analysis.engagement_level * 100) + '%';
                document.getElementById('currentGesture').textContent = 
                    analysis.gesture_type.replace('_', ' ').toUpperCase();
                document.getElementById('postureType').textContent = 
                    analysis.posture_type.replace('_', ' ').toUpperCase();
                document.getElementById('bodyLanguageText').textContent = 
                    analysis.body_language_summary;
            }

            async toggleRecording() {
                if (!this.isRecording) {
                    await this.startRecording();
                } else {
                    this.stopRecording();
                }
            }

            async startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.mediaRecorder = new MediaRecorder(stream);
                    this.recordedChunks = [];
                    this.recordedVisualFrames = []; // Reset visual frames for new recording

                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        this.processRecording();
                    };

                    this.mediaRecorder.start();
                    this.isRecording = true;

                    // Update UI
                    const button = document.getElementById('recordButton');
                    const text = document.getElementById('recordText');
                    button.classList.add('recording');
                    text.textContent = 'Stop Recording';
                    
                    document.getElementById('recordingStatus').innerHTML = 
                        '<p style="color: #000000; margin-top: 10px;">Recording audio and analyzing movement...</p>';

                } catch (error) {
                    console.error('Error starting recording:', error);
                    this.showMessageBox('Could not access microphone. Please check permissions.', 'error');
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    this.isRecording = false;

                    // Update UI
                    const button = document.getElementById('recordButton');
                    const text = document.getElementById('recordText');
                    button.classList.remove('recording');
                    text.textContent = 'Start Recording';
                    
                    document.getElementById('recordingStatus').innerHTML = 
                        '<p style="color: #333333; margin-top: 10px;">Processing audio-visual memory...</p>';
                }
            }

            async processRecording() {
                const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });
                
                // Capture current movement analysis if camera is active
                const movementSnapshot = this.isCameraActive ? { ...this.currentAnalysis } : {
                    movement_intensity: 0,
                    engagement_level: 0,
                    gesture_type: 'none',
                    posture_type: 'neutral',
                    body_language_summary: 'No visual data available'
                };
                
                await this.uploadAudio(blob, 'recording.wav', movementSnapshot, this.recordedVisualFrames);
            }

            async handleFileUpload(file) {
                if (!file) return;
                
                if (!file.type.startsWith('audio/')) {
                    this.showMessageBox('Please select an audio file.', 'warning');
                    return;
                }

                document.getElementById('uploadStatus').innerHTML = 
                    '<p style="color: #000000; margin-top: 10px;">Uploading and processing...</p>';

                // For uploaded audio, we won't have visual frames
                await this.uploadAudio(file, file.name, {
                    movement_intensity: 0,
                    engagement_level: 0,
                    gesture_type: 'none',
                    posture_type: 'neutral',
                    body_language_summary: 'No visual data available'
                }, []);
            }

            async uploadAudio(audioBlob, fileName, movementData = null, visualFrames = []) {
                try {
                    // Simulate API call to backend for audio processing and memory creation
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate delay
                    
                    // Create demo memory with actual movement data if available
                    const demoMemory = {
                        id: Date.now().toString(),
                        timestamp: Date.now() / 1000,
                        date: new Date().toISOString(),
                        emotion: ['joy', 'sadness', 'anger', 'fear', 'surprise'][Math.floor(Math.random() * 5)], // Emotion still simulated
                        text_preview: `Processed audio from ${fileName}. This memory includes body language analysis.`, // Text still generic
                        duration: Math.random() * 300 + 30,
                        movement_data: movementData, // Use the real movement data
                        visual_playback_frames: visualFrames, // Store the captured visual frames
                        multimodal_summary: movementData.body_language_summary !== 'No visual data available' ?
                            `Audio emotion matches body language; ${movementData.body_language_summary}` :
                            'Audio-only memory without visual analysis'
                    };
                    
                    // Store in localStorage for demo
                    const memories = JSON.parse(localStorage.getItem('audioVisualMemories') || '[]');
                    memories.unshift(demoMemory);
                    localStorage.setItem('audioVisualMemories', JSON.stringify(memories.slice(0, 50)));

                    // Update UI
                    document.getElementById('recordingStatus').innerHTML = 
                        '<p style="color: #000000; margin-top: 10px;">Audio-visual memory saved successfully!</p>';
                    document.getElementById('uploadStatus').innerHTML = 
                        '<p style="color: #000000; margin-top: 10px;">File processed successfully!</p>';
                    
                    // Refresh data
                    setTimeout(() => {
                        this.loadStats();
                        
                        // Clear status messages
                        document.getElementById('recordingStatus').innerHTML = '';
                        document.getElementById('uploadStatus').innerHTML = '';
                    }, 2000);

                } catch (error) {
                    console.error('Error uploading audio:', error);
                    document.getElementById('recordingStatus').innerHTML = 
                        '<p style="color: #999999; margin-top: 10px;">Error processing audio</p>';
                    document.getElementById('uploadStatus').innerHTML = 
                        '<p style="color: #999999; margin-top: 10px;">Error processing file</p>';
                }
            }

            toggleFilter(tagElement) {
                const filter = tagElement.dataset.filter;
                const [type, value] = filter.split(':');
                
                if (tagElement.classList.contains('active')) {
                    tagElement.classList.remove('active');
                    delete this.activeFilters[type];
                } else {
                    // Remove other filters of same type
                    document.querySelectorAll(`.filter-tag[data-filter^="${type}:"]`).forEach(tag => {
                        tag.classList.remove('active');
                    });
                    
                    tagElement.classList.add('active');
                    this.activeFilters[type] = value;
                }
            }

            async performQuery() {
                const query = document.getElementById('queryInput').value.trim();
                if (!query) return;

                const resultsDiv = document.getElementById('queryResults');
                resultsDiv.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        Searching your audio-visual memories...
                    </div>
                `;

                try {
                    // Simulate API call to backend
                    const results = await this.simulateQuery(query);
                    this.displayQueryResults(results);
                } catch (error) {
                    console.error('Error querying memories:', error);
                    resultsDiv.innerHTML = '<p style="color: #666666; text-align: center; padding: 40px; font-weight: 500;">Error searching memories. Please try again.</p>';
                }
            }

            async simulateQuery(query) {
                // Simulate processing delay
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                // Get demo memories
                const memories = JSON.parse(localStorage.getItem('audioVisualMemories') || '[]');
                
                // Enhanced filtering with movement data
                const filteredMemories = memories.filter(memory => {
                    const matchesQuery = memory.text_preview.toLowerCase().includes(query.toLowerCase()) ||
                                         query.toLowerCase().includes('demo') ||
                                         query.toLowerCase().includes('engagement') ||
                                         query.toLowerCase().includes('movement') ||
                                         memory.movement_data?.body_language_summary?.toLowerCase().includes(query.toLowerCase());
                    
                    let matchesFilters = true;
                    
                    // Apply filters including new movement-based ones
                    if (this.activeFilters.time) {
                        const daysAgo = parseInt(this.activeFilters.time);
                        const cutoff = Date.now() / 1000 - (daysAgo * 24 * 60 * 60);
                        matchesFilters = matchesFilters && memory.timestamp >= cutoff;
                    }
                    
                    if (this.activeFilters.engagement === 'high') {
                        matchesFilters = matchesFilters && (memory.movement_data?.engagement_level || 0) > 0.7;
                    }
                    
                    if (this.activeFilters.movement === 'active') {
                        matchesFilters = matchesFilters && (memory.movement_data?.movement_intensity || 0) > 0.5;
                    }
                    
                    if (this.activeFilters.gesture === 'confident') {
                        matchesFilters = matchesFilters && (memory.movement_data?.gesture_type === 'open_arms' || memory.movement_data?.posture_type === 'upright');
                    }
                    
                    return matchesQuery && matchesFilters;
                });

                return {
                    answer: filteredMemories.length > 0 ? 
                        `Found ${filteredMemories.length} relevant audio-visual memories matching "${query}".` :
                        `No memories found matching "${query}". Try recording with camera enabled for richer analysis.`,
                    source_documents: filteredMemories.slice(0, 5).map(memory => ({
                        content: memory.text_preview,
                        metadata: memory
                    }))
                };
            }

            displayQueryResults(results) {
                const resultsDiv = document.getElementById('queryResults');
                
                let html = `<div style="margin-bottom: 20px; padding: 15px; background: #e0e0e0; border-radius: 10px; border-left: 4px solid #000000; color: #000000;">
                    <strong>Answer:</strong> ${results.answer}
                </div>`;

                if (results.source_documents && results.source_documents.length > 0) {
                    results.source_documents.forEach(doc => {
                        const memory = doc.metadata;
                        const date = new Date(memory.timestamp * 1000).toLocaleString();
                        
                        const movementIntensity = memory.movement_data?.movement_intensity !== undefined ? Math.round(memory.movement_data.movement_intensity * 100) : 'N/A';
                        const engagementLevel = memory.movement_data?.engagement_level !== undefined ? Math.round(memory.movement_data.engagement_level * 100) : 'N/A';
                        const bodyLanguageSummary = memory.movement_data?.body_language_summary || 'No visual analysis available.';

                        html += `
                            <div class="memory-item" data-memory-id="${memory.id}">
                                <div class="memory-meta">
                                    <span>${date}</span>
                                    <span class="emotion-tag">${memory.emotion}</span>
                                </div>
                                <div class="memory-text">${doc.content}</div>
                                <div class="multimodal-summary">
                                    <h5>Body Language Analysis</h5>
                                    <p>Movement: ${movementIntensity}% | 
                                        Engagement: ${engagementLevel}% | 
                                        ${bodyLanguageSummary}</p>
                                    <p><em>${memory.multimodal_summary}</em></p>
                                </div>
                            </div>
                        `;
                    });
                     // Add event listeners to newly created memory items
                    resultsDiv.querySelectorAll('.memory-item').forEach(item => {
                        item.addEventListener('click', (e) => {
                            const memoryId = e.currentTarget.dataset.memoryId;
                            const memory = this.memories.find(m => m.id === memoryId);
                            if (memory) {
                                this.showMemoryDetail(memory);
                            }
                        });
                    });
                } else {
                    html += '<p style="text-align: center; color: #666666; padding: 20px; font-weight: 500;">No specific memories found. Try recording with camera enabled for enhanced analysis.</p>';
                }

                resultsDiv.innerHTML = html;
            }

            showMemoryDetail(memory) {
                const modal = document.getElementById('memoryModal');
                const modalBody = document.getElementById('modalBody');

                const date = new Date(memory.timestamp * 1000);
                const movementIntensity = memory.movement_data?.movement_intensity !== undefined ? Math.round(memory.movement_data.movement_intensity * 100) : 'N/A';
                const engagementLevel = memory.movement_data?.engagement_level !== undefined ? Math.round(memory.movement_data.engagement_level * 100) : 'N/A';
                const stress = memory.context_data?.biometric?.stress_score !== undefined ? Math.round(memory.context_data.biometric.stress_score * 100) : 'N/A';
                const heartRate = memory.context_data?.biometric?.heart_rate !== undefined ? memory.context_data.biometric.heart_rate : 'N/A';
                const energyLevel = memory.context_data?.biometric?.energy_level !== undefined ? Math.round(memory.context_data.biometric.energy_level * 100) : 'N/A';
                const roomTemperature = memory.context_data?.environmental?.room_temperature !== undefined ? memory.context_data.environmental.room_temperature : 'N/A';
                const weatherConditions = memory.context_data?.environmental?.weather_conditions || 'N/A';
                const venueType = memory.context_data?.environmental?.venue_type || 'N/A';
                const attentionLevel = memory.context_data?.cognitive?.attention_level !== undefined ? Math.round(memory.context_data.cognitive.attention_level * 100) : 'N/A';
                const focusQuality = memory.context_data?.cognitive?.focus_quality !== undefined ? Math.round(memory.context_data.cognitive.focus_quality * 100) : 'N/A';
                const importanceScore = memory.importance_score !== undefined ? Math.round(memory.importance_score * 100) : 'N/A';
                const gestureType = memory.movement_data?.gesture_type?.replace('_', ' ').toUpperCase() || 'N/A';
                const bodyLanguageSummary = memory.movement_data?.body_language_summary || 'No visual analysis available.';


                modalBody.innerHTML = `
                    <div style="margin-bottom: 30px;">
                        <h3 style="color: #000000; margin-bottom: 15px;">Memory from ${date.toLocaleString()}</h3>
                        <div class="memory-tags" style="margin-bottom: 20px;">
                            <span class="emotion-tag">${memory.emotion}</span>
                            <span class="emotion-tag">${venueType}</span>
                            <span class="emotion-tag">${gestureType}</span>
                        </div>
                        <div class="memory-text" style="font-size: 1.1rem; line-height: 1.6; margin-bottom: 30px; color: #333333;">
                            "${memory.text_preview}"
                        </div>
                    </div>

                    ${memory.visual_playback_frames && memory.visual_playback_frames.length > 0 ? `
                        <div style="margin-bottom: 25px;">
                            <h4 style="color: #000000; font-weight: 600; margin-bottom: 15px; font-size: 1.2rem;">Visual Playback</h4>
                            <div class="playback-container">
                                <canvas id="playbackCanvas"></canvas>
                            </div>
                            <div class="playback-controls">
                                <button id="playVisualButton" class="playback-button">Play Visual</button>
                                <button id="stopVisualButton" class="playback-button" disabled>Stop Visual</button>
                            </div>
                        </div>
                    ` : `
                        <p style="color: #666666; text-align: center; margin-bottom: 25px;">No visual playback data available for this memory.</p>
                    `}

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px;">
                        <div class="multimodal-summary" style="background: #ffffff; border-color: #e0e0e0;">
                            <h5 style="color: #000000;">Body Language Analysis</h5>
                            <div class="context-grid">
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${movementIntensity}%</div>
                                    <div class="context-label" style="color: #333333;">Movement Intensity</div>
                                </div>
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${engagementLevel}%</div>
                                    <div class="context-label" style="color: #333333;">Engagement Level</div>
                                </div>
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${gestureType}</div>
                                    <div class="context-label" style="color: #333333;">Primary Gesture</div>
                                </div>
                            </div>
                            <p style="margin-top: 15px; color: #333333;">
                                ${bodyLanguageSummary}
                            </p>
                        </div>

                        <div class="multimodal-summary" style="background: #ffffff; border-color: #e0e0e0;">
                            <h5 style="color: #000000;">Biometric Context</h5>
                            <div class="context-grid">
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${heartRate}</div>
                                    <div class="context-label" style="color: #333333;">Heart Rate (bpm)</div>
                                </div>
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${stress}%</div>
                                    <div class="context-label" style="color: #333333;">Stress Level</div>
                                </div>
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${energyLevel}%</div>
                                    <div class="context-label" style="color: #333333;">Energy Level</div>
                                </div>
                            </div>
                        </div>

                        <div class="multimodal-summary" style="background: #ffffff; border-color: #e0e0e0;">
                            <h5 style="color: #000000;">Environmental Context</h5>
                            <div class="context-grid">
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${roomTemperature}°C</div>
                                    <div class="context-label" style="color: #333333;">Temperature</div>
                                </div>
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${weatherConditions.toUpperCase()}</div>
                                    <div class="context-label" style="color: #333333;">Weather</div>
                                </div>
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${venueType.replace('_', ' ').toUpperCase()}</div>
                                    <div class="context-label" style="color: #333333;">Location Type</div>
                                </div>
                            </div>
                        </div>

                        <div class="multimodal-summary" style="background: #ffffff; border-color: #e0e0e0;">
                            <h5 style="color: #000000;">Cognitive State</h5>
                            <div class="context-grid">
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${attentionLevel}%</div>
                                    <div class="context-label" style="color: #333333;">Attention Level</div>
                                </div>
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${focusQuality}%</div>
                                    <div class="context-label" style="color: #333333;">Focus Quality</div>
                                </div>
                                <div class="context-item" style="background: #f8f8f8; border-color: #e0e0e0;">
                                    <div class="context-value" style="color: #000000;">${importanceScore}%</div>
                                    <div class="context-label" style="color: #333333;">Memory Importance</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                modal.classList.add('active');

                // Setup playback if frames exist
                if (memory.visual_playback_frames && memory.visual_playback_frames.length > 0) {
                    this.playbackCanvas = document.getElementById('playbackCanvas');
                    this.playbackCtx = this.playbackCanvas.getContext('2d');
                    this.playbackCanvas.width = 640; // Standard video width
                    this.playbackCanvas.height = 480; // Standard video height

                    document.getElementById('playVisualButton').disabled = false;
                    document.getElementById('stopVisualButton').disabled = true;

                    document.getElementById('playVisualButton').onclick = () => this.startVisualPlayback(memory.visual_playback_frames);
                    document.getElementById('stopVisualButton').onclick = () => this.stopVisualPlayback();
                } else {
                    // Disable buttons if no playback data
                    const playButton = document.getElementById('playVisualButton');
                    const stopButton = document.getElementById('stopVisualButton');
                    if (playButton) playButton.disabled = true;
                    if (stopButton) stopButton.disabled = true;
                }
            }

            startVisualPlayback(frames) {
                this.stopVisualPlayback(); // Stop any existing playback
                this.playbackFrameIndex = 0;
                document.getElementById('playVisualButton').disabled = true;
                document.getElementById('stopVisualButton').disabled = false;

                const animatePlayback = () => {
                    if (this.playbackFrameIndex < frames.length) {
                        const frame = frames[this.playbackFrameIndex];
                        this.drawLandmarksOnPlaybackCanvas(frame);
                        this.playbackFrameIndex++;
                        this.playbackAnimationFrameId = requestAnimationFrame(animatePlayback);
                    } else {
                        this.stopVisualPlayback(); // Loop or stop at end
                    }
                };
                animatePlayback();
            }

            stopVisualPlayback() {
                if (this.playbackAnimationFrameId) {
                    cancelAnimationFrame(this.playbackAnimationFrameId);
                    this.playbackAnimationFrameId = null;
                }
                this.playbackFrameIndex = 0;
                // Clear playback canvas
                if (this.playbackCtx) {
                    this.playbackCtx.clearRect(0, 0, this.playbackCanvas.width, this.playbackCanvas.height);
                }
                document.getElementById('playVisualButton').disabled = false;
                document.getElementById('stopVisualButton').disabled = true;
            }

            drawLandmarksOnPlaybackCanvas(frame) {
                if (!this.playbackCtx) return;

                this.playbackCtx.clearRect(0, 0, this.playbackCanvas.width, this.playbackCanvas.height);
                this.playbackCtx.fillStyle = '#000000'; // Black background
                this.playbackCtx.fillRect(0, 0, this.playbackCanvas.width, this.playbackCanvas.height);

                // MediaPipe DrawingUtils expects landmarks in a specific format
                // Need to convert simplified landmarks back to objects with x, y, z properties
                const convertToDrawingLandmarks = (simplified) => {
                    if (!simplified) return null;
                    return simplified.map(l => new DrawingUtils.Point(l.x, l.y, l.z));
                };

                const pose = convertToDrawingLandmarks(frame.pose);
                const face = convertToDrawingLandmarks(frame.face);
                const leftHand = convertToDrawingLandmarks(frame.leftHand);
                const rightHand = convertToDrawingLandmarks(frame.rightHand);

                // Draw landmarks
                DrawingUtils.drawConnectors(this.playbackCtx, pose, Holistic.POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
                DrawingUtils.drawLandmarks(this.playbackCtx, pose, { color: '#FF0000', lineWidth: 2 });
                DrawingUtils.drawConnectors(this.playbackCtx, face, Holistic.FACE_CONNECTIONS, { color: '#FFFFFF', lineWidth: 1 });
                DrawingUtils.drawLandmarks(this.playbackCtx, face, { color: '#E0E0E0', lineWidth: 0.5 });
                DrawingUtils.drawConnectors(this.playbackCtx, leftHand, Holistic.HAND_CONNECTIONS, { color: '#CC0000', lineWidth: 5 });
                DrawingUtils.drawLandmarks(this.playbackCtx, leftHand, { color: '#FF0000', lineWidth: 2 });
                DrawingUtils.drawConnectors(this.playbackCtx, rightHand, Holistic.HAND_CONNECTIONS, { color: '#00CC00', lineWidth: 5 });
                DrawingUtils.drawLandmarks(this.playbackCtx, rightHand, { color: '#00FF00', lineWidth: 2 });
            }

            loadStats() {
                try {
                    const memories = JSON.parse(localStorage.getItem('audioVisualMemories') || '[]');
                    
                    const now = Date.now() / 1000;
                    const weekAgo = now - (7 * 24 * 60 * 60);
                    const recentMemories = memories.filter(m => m.timestamp >= weekAgo);
                    
                    const avgEngagement = memories.length > 0 ? 
                        Math.round(memories.reduce((sum, m) => sum + (m.movement_data?.engagement_level || 0), 0) / memories.length * 100) : 0;
                    
                    const gestures = memories.map(m => m.movement_data?.gesture_type).filter(g => g && g !== 'none');
                    const gestureCounts = {};
                    gestures.forEach(gesture => {
                        gestureCounts[gesture] = (gestureCounts[gesture] || 0) + 1;
                    });

                    let mostCommonGesture = '-';
                    let maxCount = 0;
                    for (const gesture in gestureCounts) {
                        if (gestureCounts[gesture] > maxCount) {
                            maxCount = gestureCounts[gesture];
                            mostCommonGesture = gesture.replace('_', ' ').toUpperCase();
                        }
                    }

                    document.getElementById('totalMemories').textContent = memories.length;
                    document.getElementById('recentMemories').textContent = recentMemories.length;
                    document.getElementById('avgEngagement').textContent = `${avgEngagement}%`;
                    document.getElementById('topGesture').textContent = mostCommonGesture;

                } catch (error) {
                    console.error('Error loading stats:', error);
                    document.getElementById('totalMemories').textContent = 'N/A';
                    document.getElementById('recentMemories').textContent = 'N/A';
                    document.getElementById('avgEngagement').textContent = 'N/A';
                    document.getElementById('topGesture').textContent = 'N/A';
                }
            }

            showMessageBox(message, type = 'info') {
                const messageBox = document.createElement('div');
                messageBox.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: ${type === 'error' ? '#dc3545' : type === 'warning' ? '#ffc107' : '#007bff'};
                    color: white;
                    padding: 15px 25px;
                    border-radius: 8px;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.5s ease-in-out;
                    font-family: 'Inter', sans-serif;
                    font-size: 1rem;
                `;
                messageBox.textContent = message;
                document.body.appendChild(messageBox);

                setTimeout(() => {
                    messageBox.style.opacity = '1';
                }, 10);

                setTimeout(() => {
                    messageBox.style.opacity = '0';
                    messageBox.addEventListener('transitionend', () => messageBox.remove());
                }, 3000);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new AudioVisualMemoryInterface();
        });
    </script>
</body>
</html>
